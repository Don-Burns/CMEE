lmR2 <- lm_sum$r.squared
lm_Fstat <- unname(lm_sum$fstatistic[1])
curItMat <- matrix(NA, nrow = 1, ncol = 6)          # make a matrix to store the values in, then assign them.
curItMat[1] <- feed                               # feeding type
curItMat[2] <- lifestage                          # lifestage
curItMat[3] <- regSlope                           # slope of lm
curItMat[4] <- regInt                             # Intercept of lm
curItMat[5] <- lmR2                               # R2 of lm
curItMat[6] <- lm_Fstat                           # fstat of lm
i <- i + 1                                          # tick up for next row
csvData <- rbind(csvData, curItMat)
}
}
}
View(lm_coef)
View(lm_sum)
#### get data for and write csv###
counter <- 0
csvData = matrix(nrow = 1, ncol = 6)
csvHeaders = c("Regression Slope", "Regression Intercept", "R^2", "F-statistic Value", "p-value")
i <- 1 ##counter for martrix row when storing values in loop
for(feed in unique(d$Type.of.feeding.interaction)){
feedInt <- subset(d, d$Type.of.feeding.interaction == feed) # make subset of only desired feeding interaction
for(lifestage in unique(d$Predator.lifestage)){
tmp <- subset(feedInt, feedInt$Predator.lifestage == lifestage) # make a subset of the feeding interaction with only desired lifestage
counter <- counter + 1
if(dim(tmp)[1] != 0){
lm_sum <- summary(lm(Predator.mass ~ Prey.mass, data = tmp))
lm_coef <- lm_sum$coefficients
regSlope <- lm_coef[2,1]
regInt <- lm_coef[1,1]
lmR2 <- lm_sum$r.squared
lm_Fstat <- unname(lm_sum$fstatistic[1])
curItMat <- matrix(NA, nrow = 1, ncol = 6)          # make a matrix to store the values in, then assign them.
curItMat[1] <- feed                               # feeding type
curItMat[2] <- lifestage                          # lifestage
curItMat[3] <- regSlope                           # slope of lm
curItMat[4] <- regInt                             # Intercept of lm
curItMat[5] <- lmR2                               # R2 of lm
curItMat[2,6] <- lm_Fstat                           # fstat of lm
i <- i + 1                                          # tick up for next row
csvData <- rbind(csvData, curItMat)
}
}
}
View(lm_sum)
if(lm_sum$fstatistic)
{print(hi)}
lm_sum$fstatistic
bool(lm_sum$fstatistic)
source('~/Documents/CMEECourseWork/Week3/Code/PP_Regress.R')
View(lm_sum)
lm_sum$coefficients
length(lm_sum$coefficients)
nrow(lm_sum$coefficients)
csvData = matrix(nrow = 1, ncol = 6)
csvHeaders = c("Regression Slope", "Regression Intercept", "R^2", "F-statistic Value", "p-value")
i <- 1 ##counter for martrix row when storing values in loop
for(feed in unique(d$Type.of.feeding.interaction)){
feedInt <- subset(d, d$Type.of.feeding.interaction == feed) # make subset of only desired feeding interaction
for(lifestage in unique(d$Predator.lifestage)){
tmp <- subset(feedInt, feedInt$Predator.lifestage == lifestage) # make a subset of the feeding interaction with only desired lifestage
if(dim(tmp)[1] != 0){ # checks if tmp has elements to use for lm
lm_sum <- summary(lm(Predator.mass ~ Prey.mass, data = tmp)) # sets summary of lm
if(nrow(lm_sum$coefficients) > 1) {# makes sure there is some data to take from lm_sum$coefficients
lm_coef <- lm_sum$coefficients
regSlope <- lm_coef[2,1]
regInt <- lm_coef[1,1]
lmR2 <- lm_sum$r.squared
lm_Fstat <- unname(lm_sum$fstatistic[1])
curItMat <- matrix(NA, nrow = 1, ncol = 6)          # make a matrix to store the values in, then assign them.
curItMat[1] <- feed                               # feeding type
curItMat[2] <- lifestage                          # lifestage
curItMat[3] <- regSlope                           # slope of lm
curItMat[4] <- regInt                             # Intercept of lm
curItMat[5] <- lmR2                               # R2 of lm
curItMat[6] <- lm_Fstat                           # fstat of lm
i <- i + 1                                          # tick up for next row
csvData <- rbind(csvData, curItMat)
}
}
}
}
output <- as.data.frame(csvData, col.names = csvHeaders,)
View(output)
csvData = matrix(nrow = 1, ncol = 6)
csvHeaders = c("Regression Slope", "Regression Intercept", "R^2", "F-statistic Value", "p-value")
i <- 1 ##counter for martrix row when storing values in loop
for(feed in unique(d$Type.of.feeding.interaction)){
feedInt <- subset(d, d$Type.of.feeding.interaction == feed) # make subset of only desired feeding interaction
for(lifestage in unique(d$Predator.lifestage)){
tmp <- subset(feedInt, feedInt$Predator.lifestage == lifestage) # make a subset of the feeding interaction with only desired lifestage
if(dim(tmp)[1] != 0){ # checks if tmp has elements to use for lm
lm_sum <- summary(lm(Predator.mass ~ Prey.mass, data = tmp)) # sets summary of lm
if(nrow(lm_sum$coefficients) > 1) {# makes sure there is some data to take from lm_sum$coefficients
lm_coef <- lm_sum$coefficients
regSlope <- lm_coef[2,1]
regInt <- lm_coef[1,1]
lmR2 <- lm_sum$r.squared
lm_Fstat <- unname(lm_sum$fstatistic[1])
curItMat <- matrix(NA, nrow = 1, ncol = 6)          # make a matrix to store the values in, then assign them.
curItMat[1] <- feed                               # feeding type
curItMat[2] <- lifestage                          # lifestage
curItMat[3] <- regSlope                           # slope of lm
curItMat[4] <- regInt                             # Intercept of lm
curItMat[5] <- lmR2                               # R2 of lm
curItMat[6] <- lm_Fstat                           # fstat of lm
if(i == 5 | i == 6) break
i <- i + 1                                          # tick up for next row
csvData <- rbind(csvData, curItMat)
}
}
}
}
View(curItMat)
View(csvData)
csvData = matrix(nrow = 1, ncol = 6)
csvHeaders = c("Regression Slope", "Regression Intercept", "R^2", "F-statistic Value", "p-value")
i <- 1 ##counter for martrix row when storing values in loop
for(feed in unique(d$Type.of.feeding.interaction)){
feedInt <- subset(d, d$Type.of.feeding.interaction == feed) # make subset of only desired feeding interaction
for(lifestage in unique(d$Predator.lifestage)){
tmp <- subset(feedInt, feedInt$Predator.lifestage == lifestage) # make a subset of the feeding interaction with only desired lifestage
if(dim(tmp)[1] != 0){ # checks if tmp has elements to use for lm
lm_sum <- summary(lm(Predator.mass ~ Prey.mass, data = tmp)) # sets summary of lm
if(nrow(lm_sum$coefficients) > 1) {# makes sure there is some data to take from lm_sum$coefficients
lm_coef <- lm_sum$coefficients
regSlope <- lm_coef[2,1]
regInt <- lm_coef[1,1]
lmR2 <- lm_sum$r.squared
lm_Fstat <- unname(lm_sum$fstatistic[1])
curItMat <- matrix(NA, nrow = 1, ncol = 6)          # make a matrix to store the values in, then assign them.
curItMat[1] <- feed                               # feeding type
curItMat[2] <- lifestage                          # lifestage
curItMat[3] <- regSlope                           # slope of lm
curItMat[4] <- regInt                             # Intercept of lm
curItMat[5] <- lmR2                               # R2 of lm
curItMat[6] <- lm_Fstat                           # fstat of lm
#if(i == 5 | i == 6) break
i <- i + 1                                          # tick up for next row
csvData <- rbind(csvData, curItMat)
}
}
}
}
View(output)
csvData = matrix(nrow = 1, ncol = 6)
csvHeaders = c("Regression Slope", "Regression Intercept", "R^2", "F-statistic Value", "p-value")
i <- 1 ##counter for martrix row when storing values in loop
for(feed in unique(d$Type.of.feeding.interaction)){
feedInt <- subset(d, d$Type.of.feeding.interaction == feed) # make subset of only desired feeding interaction
for(lifestage in unique(d$Predator.lifestage)){
tmp <- subset(feedInt, feedInt$Predator.lifestage == lifestage) # make a subset of the feeding interaction with only desired lifestage
if(dim(tmp)[1] != 0){ # checks if tmp has elements to use for lm
lm_sum <- summary(lm(Predator.mass ~ Prey.mass, data = tmp)) # sets summary of lm
if(nrow(lm_sum$coefficients) > 1) {# makes sure there is some data to take from lm_sum$coefficients
lm_coef <- lm_sum$coefficients
regSlope <- lm_coef[2,1]
regInt <- lm_coef[1,1]
lmR2 <- lm_sum$r.squared
lm_Fstat <- unname(lm_sum$fstatistic[1])
curItMat <- matrix(NA, nrow = 1, ncol = 6)          # make a matrix to store the values in, then assign them.
curItMat[1] <- feed                               # feeding type
curItMat[2] <- lifestage                          # lifestage
curItMat[3] <- regSlope                           # slope of lm
curItMat[4] <- regInt                             # Intercept of lm
curItMat[5] <- lmR2                               # R2 of lm
curItMat[6] <- lm_Fstat                           # fstat of lm
if(i == 8) break
i <- i + 1                                          # tick up for next row
csvData <- rbind(csvData, curItMat)
}
}
}
}
View(curItMat)
csvData = matrix(nrow = 1, ncol = 6)
csvHeaders = c("Regression Slope", "Regression Intercept", "R^2", "F-statistic Value", "p-value")
i <- 1 ##counter for martrix row when storing values in loop
for(feed in unique(d$Type.of.feeding.interaction)){
feedInt <- subset(d, d$Type.of.feeding.interaction == feed) # make subset of only desired feeding interaction
for(lifestage in unique(d$Predator.lifestage)){
tmp <- subset(feedInt, feedInt$Predator.lifestage == lifestage) # make a subset of the feeding interaction with only desired lifestage
if(dim(tmp)[1] != 0){ # checks if tmp has elements to use for lm
lm_sum <- summary(lm(Predator.mass ~ Prey.mass, data = tmp)) # sets summary of lm
if(nrow(lm_sum$coefficients) > 1) {# makes sure there is some data to take from lm_sum$coefficients
lm_coef <- lm_sum$coefficients
regSlope <- lm_coef[2,1]
regInt <- lm_coef[1,1]
lmR2 <- lm_sum$r.squared
lm_Fstat <- unname(lm_sum$fstatistic[1])
curItMat <- matrix(NA, nrow = 1, ncol = 6)          # make a matrix to store the values in, then assign them.
curItMat[1] <- feed                               # feeding type
curItMat[2] <- lifestage                          # lifestage
curItMat[3] <- regSlope                           # slope of lm
curItMat[4] <- regInt                             # Intercept of lm
curItMat[5] <- lmR2                               # R2 of lm
curItMat[6] <- lm_Fstat                           # fstat of lm
csvData <- rbind(csvData, curItMat)
if(i == 9) break
i <- i + 1                                          # tick up for next row
}
}
}
}
csvData = matrix(nrow = 1, ncol = 6)
csvHeaders = c("Regression Slope", "Regression Intercept", "R^2", "F-statistic Value", "p-value")
i <- 1 ##counter for martrix row when storing values in loop
for(feed in unique(d$Type.of.feeding.interaction)){
feedInt <- subset(d, d$Type.of.feeding.interaction == feed) # make subset of only desired feeding interaction
for(lifestage in unique(d$Predator.lifestage)){
tmp <- subset(feedInt, feedInt$Predator.lifestage == lifestage) # make a subset of the feeding interaction with only desired lifestage
if(dim(tmp)[1] != 0){ # checks if tmp has elements to use for lm
lm_sum <- summary(lm(Predator.mass ~ Prey.mass, data = tmp)) # sets summary of lm
if(nrow(lm_sum$coefficients) > 1) {# makes sure there is some data to take from lm_sum$coefficients
lm_coef <- lm_sum$coefficients
regSlope <- lm_coef[2,1]
regInt <- lm_coef[1,1]
lmR2 <- lm_sum$r.squared
lm_Fstat <- unname(lm_sum$fstatistic[1])
curItMat <- matrix(NA, nrow = 1, ncol = 6)          # make a matrix to store the values in, then assign them.
curItMat[1] <- feed                               # feeding type
curItMat[2] <- lifestage                          # lifestage
curItMat[3] <- regSlope                           # slope of lm
curItMat[4] <- regInt                             # Intercept of lm
curItMat[5] <- lmR2                               # R2 of lm
curItMat[6] <- lm_Fstat                           # fstat of lm
csvData <- rbind(csvData, curItMat)
if(curItMat[5=1]) break
i <- i + 1                                          # tick up for next row
}
}
}
}
csvData = matrix(nrow = 1, ncol = 6)
csvHeaders = c("Regression Slope", "Regression Intercept", "R^2", "F-statistic Value", "p-value")
i <- 1 ##counter for martrix row when storing values in loop
for(feed in unique(d$Type.of.feeding.interaction)){
feedInt <- subset(d, d$Type.of.feeding.interaction == feed) # make subset of only desired feeding interaction
for(lifestage in unique(d$Predator.lifestage)){
tmp <- subset(feedInt, feedInt$Predator.lifestage == lifestage) # make a subset of the feeding interaction with only desired lifestage
if(dim(tmp)[1] != 0){ # checks if tmp has elements to use for lm
lm_sum <- summary(lm(Predator.mass ~ Prey.mass, data = tmp)) # sets summary of lm
if(nrow(lm_sum$coefficients) > 1) {# makes sure there is some data to take from lm_sum$coefficients
lm_coef <- lm_sum$coefficients
regSlope <- lm_coef[2,1]
regInt <- lm_coef[1,1]
lmR2 <- lm_sum$r.squared
lm_Fstat <- unname(lm_sum$fstatistic[1])
curItMat <- matrix(NA, nrow = 1, ncol = 6)          # make a matrix to store the values in, then assign them.
curItMat[1] <- feed                               # feeding type
curItMat[2] <- lifestage                          # lifestage
curItMat[3] <- regSlope                           # slope of lm
curItMat[4] <- regInt                             # Intercept of lm
curItMat[5] <- lmR2                               # R2 of lm
curItMat[6] <- lm_Fstat                           # fstat of lm
csvData <- rbind(csvData, curItMat)
if(curItMat[5=1]) break
i <- i + 1                                          # tick up for next row
}
}
}
}
csvData = matrix(nrow = 1, ncol = 6)
csvHeaders = c("Regression Slope", "Regression Intercept", "R^2", "F-statistic Value", "p-value")
i <- 1 ##counter for martrix row when storing values in loop
for(feed in unique(d$Type.of.feeding.interaction)){
feedInt <- subset(d, d$Type.of.feeding.interaction == feed) # make subset of only desired feeding interaction
for(lifestage in unique(d$Predator.lifestage)){
tmp <- subset(feedInt, feedInt$Predator.lifestage == lifestage) # make a subset of the feeding interaction with only desired lifestage
if(dim(tmp)[1] != 0){ # checks if tmp has elements to use for lm
lm_sum <- summary(lm(Predator.mass ~ Prey.mass, data = tmp)) # sets summary of lm
if(nrow(lm_sum$coefficients) > 1) {# makes sure there is some data to take from lm_sum$coefficients
lm_coef <- lm_sum$coefficients
regSlope <- lm_coef[2,1]
regInt <- lm_coef[1,1]
lmR2 <- lm_sum$r.squared
lm_Fstat <- unname(lm_sum$fstatistic[1])
curItMat <- matrix(NA, nrow = 1, ncol = 6)          # make a matrix to store the values in, then assign them.
curItMat[1] <- feed                               # feeding type
curItMat[2] <- lifestage                          # lifestage
curItMat[3] <- regSlope                           # slope of lm
curItMat[4] <- regInt                             # Intercept of lm
curItMat[5] <- lmR2                               # R2 of lm
curItMat[6] <- lm_Fstat                           # fstat of lm
csvData <- rbind(csvData, curItMat)
if(curItMat[5=1]) {break}
i <- i + 1                                          # tick up for next row
}
}
}
}
csvData = matrix(nrow = 1, ncol = 6)
csvHeaders = c("Regression Slope", "Regression Intercept", "R^2", "F-statistic Value", "p-value")
i <- 1 ##counter for martrix row when storing values in loop
for(feed in unique(d$Type.of.feeding.interaction)){
feedInt <- subset(d, d$Type.of.feeding.interaction == feed) # make subset of only desired feeding interaction
for(lifestage in unique(d$Predator.lifestage)){
tmp <- subset(feedInt, feedInt$Predator.lifestage == lifestage) # make a subset of the feeding interaction with only desired lifestage
if(dim(tmp)[1] != 0){ # checks if tmp has elements to use for lm
lm_sum <- summary(lm(Predator.mass ~ Prey.mass, data = tmp)) # sets summary of lm
if(nrow(lm_sum$coefficients) > 1) {# makes sure there is some data to take from lm_sum$coefficients
lm_coef <- lm_sum$coefficients
regSlope <- lm_coef[2,1]
regInt <- lm_coef[1,1]
lmR2 <- lm_sum$r.squared
lm_Fstat <- unname(lm_sum$fstatistic[1])
curItMat <- matrix(NA, nrow = 1, ncol = 6)          # make a matrix to store the values in, then assign them.
curItMat[1] <- feed                               # feeding type
curItMat[2] <- lifestage                          # lifestage
curItMat[3] <- regSlope                           # slope of lm
curItMat[4] <- regInt                             # Intercept of lm
curItMat[5] <- lmR2                               # R2 of lm
curItMat[6] <- lm_Fstat                           # fstat of lm
csvData <- rbind(csvData, curItMat)
if(i == 9) break
i <- i + 1                                          # tick up for next row
}
}
}
}
csvData = matrix(nrow = 1, ncol = 6)
csvHeaders = c("Regression Slope", "Regression Intercept", "R^2", "F-statistic Value", "p-value")
i <- 1 ##counter for martrix row when storing values in loop
for(feed in unique(d$Type.of.feeding.interaction)){
feedInt <- subset(d, d$Type.of.feeding.interaction == feed) # make subset of only desired feeding interaction
for(lifestage in unique(d$Predator.lifestage)){
tmp <- subset(feedInt, feedInt$Predator.lifestage == lifestage) # make a subset of the feeding interaction with only desired lifestage
if(dim(tmp)[1] != 0){ # checks if tmp has elements to use for lm
lm_sum <- summary(lm(Predator.mass ~ Prey.mass, data = tmp)) # sets summary of lm
if(nrow(lm_sum$coefficients) > 1) {# makes sure there is some data to take from lm_sum$coefficients
lm_coef <- lm_sum$coefficients
regSlope <- lm_coef[2,1]
regInt <- lm_coef[1,1]
lmR2 <- lm_sum$r.squared
lm_Fstat <- unname(lm_sum$fstatistic[1])
curItMat <- matrix(NA, nrow = 1, ncol = 6)          # make a matrix to store the values in, then assign them.
curItMat[1] <- feed                               # feeding type
curItMat[2] <- lifestage                          # lifestage
curItMat[3] <- regSlope                           # slope of lm
curItMat[4] <- regInt                             # Intercept of lm
curItMat[5] <- lmR2                               # R2 of lm
curItMat[6] <- lm_Fstat                           # fstat of lm
csvData <- rbind(csvData, curItMat)
if(curItMat[5] == 1) break
i <- i + 1                                          # tick up for next row
}
}
}
}
View(lm_sum)
View(curItMat)
csvData = matrix(nrow = 1, ncol = 6)
csvHeaders = c("Regression Slope", "Regression Intercept", "R^2", "F-statistic Value", "p-value")
i <- 1 ##counter for martrix row when storing values in loop
for(feed in unique(d$Type.of.feeding.interaction)){
feedInt <- subset(d, d$Type.of.feeding.interaction == feed) # make subset of only desired feeding interaction
for(lifestage in unique(d$Predator.lifestage)){
tmp <- subset(feedInt, feedInt$Predator.lifestage == lifestage) # make a subset of the feeding interaction with only desired lifestage
if(dim(tmp)[1] != 0){ # checks if tmp has elements to use for lm
lm_sum <- summary(lm(Predator.mass ~ Prey.mass, data = tmp)) # sets summary of lm
if(nrow(lm_sum$coefficients) > 1) {# makes sure there is some data to take from lm_sum$coefficients
lm_coef <- lm_sum$coefficients
regSlope <- lm_coef[2,1]
regInt <- lm_coef[1,1]
lmR2 <- lm_sum$r.squared
lm_Fstat <- unname(lm_sum$fstatistic[1])
curItMat <- matrix(NA, nrow = 1, ncol = 6)          # make a matrix to store the values in, then assign them.
curItMat[1] <- feed                               # feeding type
curItMat[2] <- lifestage                          # lifestage
curItMat[3] <- regSlope                           # slope of lm
curItMat[4] <- regInt                             # Intercept of lm
curItMat[5] <- lmR2                               # R2 of lm
curItMat[6] <- lm_Fstat                           # fstat of lm
csvData <- rbind(csvData, curItMat)
#if(curItMat[5] == 1) break
i <- i + 1                                          # tick up for next row
}
}
}
}
csvData = matrix(nrow = 1, ncol = 6)
csvHeaders = c("Regression Slope", "Regression Intercept", "R^2", "F-statistic Value", "p-value")
i <- 1 ##counter for martrix row when storing values in loop
for(feed in unique(d$Type.of.feeding.interaction)){
feedInt <- subset(d, d$Type.of.feeding.interaction == feed) # make subset of only desired feeding interaction
for(lifestage in unique(d$Predator.lifestage)){
tmp <- subset(feedInt, feedInt$Predator.lifestage == lifestage) # make a subset of the feeding interaction with only desired lifestage
if(dim(tmp)[1] != 0){ # checks if tmp has elements to use for lm
lm_sum <- summary(lm(Predator.mass ~ Prey.mass, data = tmp)) # sets summary of lm
if(nrow(lm_sum$coefficients) > 1) {# makes sure there is some data to take from lm_sum$coefficients
lm_coef <- lm_sum$coefficients
regSlope <- lm_coef[2,1]
regInt <- lm_coef[1,1]
lmR2 <- lm_sum$r.squared
lm_Fstat <- unname(lm_sum$fstatistic[1])
curItMat <- matrix(NA, nrow = 1, ncol = 6)          # make a matrix to store the values in, then assign them.
curItMat[1] <- feed                               # feeding type
curItMat[2] <- lifestage                          # lifestage
curItMat[3] <- regSlope                           # slope of lm
curItMat[4] <- regInt                             # Intercept of lm
curItMat[5] <- lmR2                               # R2 of lm
curItMat[6] <- lm_Fstat                           # fstat of lm
csvData <- rbind(csvData, curItMat)
if(is.nan(curItMat[6])) break
i <- i + 1                                          # tick up for next row
}
}
}
}
source('~/Documents/CMEECourseWork/Week3/Code/PP_Regress.R')
View(csvData)
source('~/Documents/CMEECourseWork/Week3/Code/PP_Regress.R')
View(curItMat)
View(csvData)
View(lm_coef)
View(output)
View(output)
output <- as.data.frame(csvData, col.names = csvHeaders,) ## save as a data frame ready for saving
csvData <- csvData[-1] # remove first row of Na that is left from first defining the matrix
output <- as.data.frame(csvData, col.names = csvHeaders,) ## save as a data frame ready for saving
View(output)
csvData = matrix(nrow = 1, ncol = 6)
csvHeaders = c("Regression Slope", "Regression Intercept", "R^2", "F-statistic Value", "p-value")
i <- 1 ##counter for martrix row when storing values in loop
for(feed in unique(d$Type.of.feeding.interaction)){
feedInt <- subset(d, d$Type.of.feeding.interaction == feed) # make subset of only desired feeding interaction
for(lifestage in unique(d$Predator.lifestage)){
tmp <- subset(feedInt, feedInt$Predator.lifestage == lifestage) # make a subset of the feeding interaction with only desired lifestage
if(dim(tmp)[1] != 0){ # checks if tmp has elements to use for lm
lm_sum <- summary(lm(Predator.mass ~ Prey.mass, data = tmp)) # sets summary of lm
if(nrow(lm_sum$coefficients) > 1) {# makes sure there is some data to take from lm_sum$coefficients
lm_coef <- lm_sum$coefficients
regSlope <- lm_coef[2,1]
regInt <- lm_coef[1,1]
lmR2 <- lm_sum$r.squared
lm_Fstat <- unname(lm_sum$fstatistic[1])
curItMat <- matrix(NA, nrow = 1, ncol = 6)          # make a matrix to store the values in, then assign them.
curItMat[1] <- feed                               # feeding type
curItMat[2] <- lifestage                          # lifestage
curItMat[3] <- regSlope                           # slope of lm
curItMat[4] <- regInt                             # Intercept of lm
curItMat[5] <- lmR2                               # R2 of lm
curItMat[6] <- lm_Fstat                           # fstat of lm
csvData <- rbind(csvData, curItMat)
if(is.nan(curItMat[6])) stop("found NaN")
i <- i + 1                                          # tick up for next row
}
}
}
}
csvData <- csvData[-1] # remove first row of Na that is left from first defining the matrix
output <- as.data.frame(csvData, col.names = csvHeaders,) ## save as a data frame ready for saving
output <- as.data.frame(csvData, row.names = NULL, col.names = csvHeaders,) ## save as a data frame ready for saving
output <- as.data.frame(csvData, col.names = csvHeaders, stringsAsFactors = T) ## save as a data frame ready for saving
View(output)
csvData = matrix(nrow = 1, ncol = 6)
csvHeaders = c("Regression Slope", "Regression Intercept", "R^2", "F-statistic Value", "p-value")
i <- 1 ##counter for martrix row when storing values in loop
for(feed in unique(d$Type.of.feeding.interaction)){
feedInt <- subset(d, d$Type.of.feeding.interaction == feed) # make subset of only desired feeding interaction
for(lifestage in unique(d$Predator.lifestage)){
tmp <- subset(feedInt, feedInt$Predator.lifestage == lifestage) # make a subset of the feeding interaction with only desired lifestage
if(dim(tmp)[1] != 0){ # checks if tmp has elements to use for lm
lm_sum <- summary(lm(Predator.mass ~ Prey.mass, data = tmp)) # sets summary of lm
if(nrow(lm_sum$coefficients) > 1) {# makes sure there is some data to take from lm_sum$coefficients
lm_coef <- lm_sum$coefficients
regSlope <- lm_coef[2,1]
regInt <- lm_coef[1,1]
lmR2 <- lm_sum$r.squared
lm_Fstat <- unname(lm_sum$fstatistic[1])
curItMat <- matrix(NA, nrow = 1, ncol = 6)          # make a matrix to store the values in, then assign them.
curItMat[1] <- feed                               # feeding type
curItMat[2] <- lifestage                          # lifestage
curItMat[3] <- regSlope                           # slope of lm
curItMat[4] <- regInt                             # Intercept of lm
curItMat[5] <- lmR2                               # R2 of lm
curItMat[6] <- lm_Fstat                           # fstat of lm
csvData <- rbind(csvData, curItMat)
if(is.nan(curItMat[6])) stop("found NaN")
i <- i + 1                                          # tick up for next row
}
}
}
}
View(csvData)
csvData <- csvData[-1,] # remove first row of Na that is left from first defining the matrix
output <- as.data.frame(csvData, col.names = csvHeaders, stringsAsFactors = T) ## save as a data frame ready for saving
View(output)
output <- as.data.frame(csvData, col.names = c("Regression Slope", "Regression Intercept", "R^2", "F-statistic Value", "p-value"), stringsAsFactors = T) ## save as a data frame ready for saving
View(output)
source('~/Documents/CMEECourseWork/Week3/Code/PP_Regress.R')
output <- as.data.frame(csvData) ## save as a data frame ready for saving
names(output) <- csvHeaders
View(output)
source('~/Documents/CMEECourseWork/Week3/Code/PP_Regress.R')
View(lm_sum)
View(lm_coef)
source('~/Documents/CMEECourseWork/Week3/Code/PP_Regress.R')
source('~/Documents/CMEECourseWork/Week3/Code/PP_Regress.R')
View(output)
source('~/Documents/CMEECourseWork/Week3/Code/PP_Regress.R')
source('~/Documents/CMEECourseWork/Week3/Code/PP_Regress.R')
View(csvData)
csvData <- csvData[-1,] # remove first row of Na that is left from first defining the matrix
output <- as.data.frame(csvData, row.names = F) ## save as a data frame ready for saving
names(output) <- csvHeaders # add row names
output <- as.data.frame(csvData, row.names = F)
View(output)
source('~/Documents/CMEECourseWork/Week3/Code/PP_Regress.R')
source('~/Documents/CMEECourseWork/Week3/Code/PP_Regress.R')
View(csvData)
