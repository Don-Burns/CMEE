Starting weekly assessment for Donal, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 127.83 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week6, Week1, Week7, Assessment, Stats2, HPC, Week5, Week2, Week4, .git, C_Week, Week3, MiniProject

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~ 
*.tmp
__pycache__
*.pyc
./Week4/notes # dont need the notes from Week4 on git
*.shp
.Rhistory
*.ppt*
*.odp
.idea/
.vscode**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# My CMEE Course Repository
## **Description**
A depository for following the CMEE course at Imperial College London. 
The depositoryis meant as a mean of practicing various tools useful in computational ecology such as R, python and more.
As such the material found in [The Multilingual Quantitative Biologist](https://mhasoba.github.io/TheMulQuaBio/) is the material that will be followed to get a basic grasp of how to use these tools.

## **Structure**
The course is broken into weeks with each week covering different material.  This is reflected in the folder structure of this depository. Each week's folder will contain a data, results and code folder relating to that week's topics.

## **Table of Contents**
[**Week 1**](https://github.com/Don-Burns/CMEECourseWork/tree/master/Week1)

    Unix Terminal 
    Shell Scripting (Bash)
    Latex Document creation

[**Week 2**](https://github.com/Don-Burns/CMEECourseWork/tree/master/Week2)

    Python I Week

[**Week 3**](https://github.com/Don-Burns/CMEECourseWork/tree/master/Week3)

    R Week

[**Week 4**](https://github.com/Don-Burns/CMEECourseWork/tree/master/Week4)

    Statistics Week

[**Week 5**](https://github.com/Don-Burns/CMEECourseWork/tree/master/Week5)

    GIS Week

[**Week 6**](https://github.com/Don-Burns/CMEECourseWork/tree/master/Week6)

    Bioinformatics Week

[**Week 7**](https://github.com/Don-Burns/CMEECourseWork/tree/master/Week7)

    Python II Week

[**Week 8**](https://github.com/Don-Burns/CMEECourseWork/tree/master/MiniProject)

    Mini Project Week

[**Week 7**](https://github.com/Don-Burns/CMEECourseWork/tree/master/HPC)

    HPC Week**********************************************************************

======================================================================
Looking for the weekly directories...

Found 8 weekly directories: C_Week, Week1, Week2, Week3, Week4, Week5, Week6, Week7

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: Code, sandbox, data, Results

Found the following files: .gitignore, README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# Week 2 CMEE Course Repository   

## Structure  
Contains [`Code`](https://github.com/Don-Burns/CMEECourseWork/tree/master/Week2/Code) with the code produced during this week's class', [`Data`](https://github.com/Don-Burns/CMEECourseWork/tree/master/Week2/Data) with the data required for the code to run and [`Results`](https://github.com/Don-Burns/CMEECourseWork/tree/master/Week2/Results) which is where the code will output the resulting file of code if any is produced. This week also contains [`SandBox`](https://github.com/Don-Burns/CMEECourseWork/tree/master/Week2/SandBox) which is where simpler concepts are tested. 

## **Table of Contents**
### [**Code**](https://github.com/Don-Burns/CMEECourseWork/tree/master/Week2/Code) - List of codes with brief descriptions.
```
basic_csv.py
```
takes a file `../data/testcsv.csv` and writes a file to `../Results` called bodymass.csv  which contains only the species name and body mass

```
basic_io3.py
```
Creates a binary file `../testp.p` containing a dictionary with 2 keys.

```
control_flow.py
```
Some functions exemplicfying the use of control statements.

```
oaks.py
```
  Finds just those taxa that are oak trees from a list of species

```
align_seqs_fasta.py
```
A programme which takes two genetic sequences and aligns them to provide the best direct match possible.
It will run even if no inputs are given using short examples sequences, by using files `407228326.fasta` and `407228412.fasta` found within `../data/fasta` 

```
lc1.py
```
  A script taking birds latin names, common names and body mass and outputting them alone.

```
basic_io2.py
```
Takes# `../sandbox/testout.txt` and adds new lines at the end of each line.

```
boilerplate.py
```
Description of this program or application.  You can use several lines.

```
scope.py
```
A script looking at how global and local funtions are handled inside and outside functions.

```
loops.py
```
  A script practicing use of FOR loops in Python

```
sysargv.py
```
  A script examining how sys.argv is handeled in Python.

```
lc2.py
```
  A script examining how sys.argv is handeled in Python.

```
tuple.py
```
  A script taking a tuple containing tuples with the latin name, common name and body mass of various bird species.  

```
oaks_debugme.py
```
A program which parses a list and takes all members of the 'Quercuss' genus and saves them to a sperate file in `../data`.

```
using_name.py
```
  A script looking at how __main__ is handled in python.

```
align_seqs_better.py
```
A programme which takes two genetic sequences and aligns them to provide the best direct match possible.
It will run even if no inputs are given using short examples sequences, by using files `407228326.fasta` and `407228412.fasta` found within `../data/fasta`.  Uses `pickle` to speed up the allignment for very large files.

```
cfexercises2.py
```
A series of tests looking at how python does some simple calculations and printing a result if they meet various criterea.

```
dictionary.py
```
  A script taking a list with species stored with their order as a tuple in a list. It creates a dictionary mapping orders as keys and species as values to their respective orders.

```
basic_io1.py
```
Takes a file prints it then removes blank lines and outputs to the terminal.

```
cfexercises1.py
```
A test of writting simple function to execute simple operation on a number, or list of numbers.

```
align_seqs.py
```
A programme which takes two genetic sequences and aligns them to provide the best direct match possible.
It will run even if no inputs are given using short examples sequences, by using align_seqs.csv found within `../data`.

```
debugm.py
```
A script for experimenting with debugging in python.

```
test_control_flow.py
```
A script to test how to write and use doctests using some functions exemplicfying the use of control statements.

### [**Data**](https://github.com/Don-Burns/CMEECourseWork/tree/master/Week2/Data)  
Where inputs for the code are stored.

### [**SandBox**](https://github.com/Don-Burns/CMEECourseWork/tree/master/Week1/SandBox)  
For any testing of code or files.**********************************************************************

Found following files in results directory: seq_alignment_better.txt, seq_alignment_fasta.txt, .gitignore, seq_alignment.txt...
ideally, Results directory should be empty other than, perhaps, a readme. 

Found 23 code files: lc2.py, boilerplate.py, basic_csv.py, cfexercises2.py, align_seqs_better.py, dictionary.py, scope.py, basic_io3.py, cfexercises1.py, tuple.py, lc1.py, oaks_debugme.py, oaks.py, loops.py, using_name.py, align_seqs.py, basic_io2.py, sysargv.py, align_seqs_fasta.py, control_flow.py, debugm.py, test_control_flow.py, basic_io1.py

Found the following extra files: .gitignore
0.5 pt deducted per extra file

Current Points = 99.5

======================================================================
Testing script/code files...

======================================================================
Inspecting script file lc2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" A script examining how sys.argv is handeled in Python"""

__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'
# Author: Donal Burns (db319@ic.ac.uk)
# Date: Oct 2019
# Desc: A script examining how sys.argv is handeled in Python.

# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.

Over100 = [entry for entry in rainfall if entry[1] > 100]
print(Over100)
 
# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm. 

under50 = [entry for entry in rainfall if entry[1] < 50]
print(under50)

# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !). 

Over100 = []
for entry in rainfall:
    if entry[1] > 100: 
        Over100.append(entry)

print(Over100)

under50 = []
for entry in rainfall:
    if entry[1] < 50:
        under50.append(entry)

print(under50)**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 

**********************************************************************
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
[('MAR', 49.9), ('SEP', 27.0)]
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
[('MAR', 49.9), ('SEP', 27.0)]

**********************************************************************

Code ran without errors

Time consumed = 0.05110s

======================================================================
Inspecting script file boilerplate.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""Description of this program or application.  You can use several lines."""

__appname__ = '[application name here]'
__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'
__liscense__ = "License for this code/program"

## imports ##
import sys # module to interface our program with the operating system.

## constants ##


## functions ##
def main(argv):
    """Main entry point of the program """
    print('This is a boilerplate') # NOTE: indented using two tabs or 4 spaces
    return 0

if __name__ == "__main__":
    """Makes sure the "main" function is called from the command line"""
    status = main(sys.argv)
    sys.exit("I am exiting now!")
**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 99.5

Output (only first 500 characters): 

**********************************************************************
This is a boilerplate

**********************************************************************

Encountered error (or warning):
I am exiting now!

======================================================================
Inspecting script file basic_csv.py...

File contents are:
**********************************************************************
""" takes a file '../data/testcsv.csv' and writes a file to ../Results called bodymass.csv  which contains only the species name and body mass"""


import csv

# Read a file containing:
# 'Species, 'Infraorder', 'Family, ' Distribution', 'Body mass male'
f = open('../data/testcsv.csv', 'r')

csvread = csv.reader(f)
temp = []
for row in csvread:
    temp.append(tuple(row))
    if row[0] == "Species":
        print("Data layout:")
        print(str(row) + "\n")
        
    else:    
        print("The species is", row[0])
        print(str(row) + "\n")
    
f.close()

# write a file containing only species name and Body mass
f = open('../data/testcsv.csv', 'r')
g = open('../data/bodymass.csv', 'w')

csvread = csv.reader(f)
csvwrite = csv.writer(g)
for row in csvread:
    print(row)
    csvwrite.writerow([[row[0]], row[4]])
print("\n\nFile has been saved as 'bodymass.csv' within /data \n")
f.close()
g.close()**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 

**********************************************************************
Data layout:
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']

The species is Daubentonia_madagascariensis
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']

The species is Allocebus_trichotis
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']

The species is Avahi_laniger
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']

The species is Avahi_occidentalis
['Avahi_occidentalis', 'Lemurifo
**********************************************************************

Code ran without errors

Time consumed = 0.02886s

======================================================================
Inspecting script file cfexercises2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""A series of tests looking at how python does some simple calculations and printing a result if they meet various criterea."""

__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'


for j in range(12):  # prints hello 4 times
    if j % 3 == 0:
        print('hello')

for j in range(15):  #prints hello 5 times
    if j % 5 == 3:  # prints on 3, 8, 13
        print('hello')
    elif j % 4 == 3: # prints on 7,15
        print('hello')

z = 0
while z != 15:  # prints "hello" 5 times
    print('hello')
    z = z + 3

z = 12      # prints "hello" 8 times
while z < 100:
    if z == 31:
        for k in range(7):
            print('hello')
    elif z == 18:
        print('hello')
    z = z + 1

**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 

**********************************************************************
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello

**********************************************************************

Code ran without errors

Time consumed = 0.03194s

======================================================================
Inspecting script file align_seqs_better.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" A programme which takes two genetic sequences and aligns them to provide the best direct match possible.
It will run even if no inputs are given using short examples sequences, by using files `407228326.fasta` and `407228412.fasta` found within `../data/fasta`.  Uses `pickle` to speed up the allignment for very large files."""


__appname__ = 'align_seqs_fasta.py'
__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'

## possible improvements
# use tags in file

## little print to terminal to show user the script is running.
print("Processing...")

##Imports##

import sys 
import csv 
import pickle




###for differentiating files

##if not user arguments are given run with test files
if len(sys.argv) == 1:

    with open("../data/fasta/407228326.fasta","r") as reader:
        
        seq1 = ""
        for s in reader.readlines()[1:]:  #reads all lines starting with line 2
            s = s.rstrip('\n')
            seq1 = seq1 + s

    with open("../data/fasta/407228412.fasta") as reader:
        
        seq2 = ""
        for s in reader.readlines()[1:]:
            s = s.rstrip('\n')
            seq2 = seq2 + s
    
#run with user designated file otherwise
else:

    with open(sys.argv[1]) as reader:

        seq1 = ""
        for s in reader.readlines()[1:]:
            s = s.rstrip('\n')
            seq1 = seq1 + s

    with open(sys.argv[2]) as reader:
        
        seq2 = ""
        for s in reader.readlines()[1:]:
            s = s.rstrip('\n')
            seq2 = seq2 + s




# Two example sequences to match, will run should no other files be specified.  found as align_seqs.csv in ../Results
# seq2 = "ATCGCCGGATTACGGG"
# seq1 = "CAATTCGGAT"

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    """ A function that computes a score by returning the number of matches starting from arbitrary startpoint (chosen by user)"""
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # # some formatted output
    # print("." * startpoint + matched)           
    # print("." * startpoint + s2)
    # print(s1)
    # print(score) 
    # print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)



# now try to find the best match (highest score) for the two sequences
my_best_align = [""]
my_best_score = -1
tmp = None
# test = []
for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    # test.append(z)
    if z > my_best_score:
        with open("../data/align_tmp.txt", "wb") as file:
            # pickle.load(file) ## dont need to load because it will overwrite ?
            my_best_align = ["." * i + s2]
            my_best_score = z 
            pickle.dump(my_best_align, file)
            
    ##for storage of values which are equal to the current best score.
    elif z == my_best_score:
        tmp = ["." * i + s2]
        with open("../data/align_tmp.txt", "br+") as file:
            pickle.load(file)
            my_best_align.append(tmp)  
            pickle.dump(my_best_align, file)
            print(i)
            print(z)
            # import ipdb; ipdb.set_trace()
    ## if no higher or equal continue
    else:
        None



def main(argv):
    """prints all alignments with scores and saves the alignment with the best score to ../Results"""
    with open("../Results/seq_alignment_better.txt","w") as file:
        ##writes the file with best score        
        with open("../data/align_tmp.txt","rb") as tmp:
            pickle.load(tmp)

            for i in my_best_align:
                
                file.write(str(i) +"\n")
                file.write(s1 + "\n")
                file.write("Best score:" + str(my_best_score) + "\n")
                # import ipdb; ipdb.set_trace()
        print("DING! All Done.")

# print(set(test))
# print(test)
###  NOTE need to loop through lines of my_best _align for final file print?

if (__name__ =="__main__"):
    status = main(sys.argv)
    sys.exit(status)**********************************************************************

Testing align_seqs_better.py...

align_seqs_better.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 99.5

Output (only first 500 characters): 

**********************************************************************
Processing...
DING! All Done.

**********************************************************************

Code ran without errors

Time consumed = 3.43679s

======================================================================
Inspecting script file dictionary.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""A script taking a list with species stored with their order as a tuple in a list. It creates a dictionary mapping orders as keys and species as values to their respective orders."""

__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'
# Author: Donal Burns (db319@ic.ac.uk)
# Date: Oct 2019
# Desc: A script taking a list with species stored with their order as a tuple in a list. It creates a dictionary mapping orders as keys and species as values to their respective orders.

taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

# Write a short python script to populate a dictionary called taxa_dic 
# derived from  taxa so that it maps order names to sets of taxa. 
# E.g. 'Chiroptera' : set(['Myotis lucifugus']) etc. 
taxa = set(taxa)
taxa_dic = {}

for entry in taxa:
        ##if not on keys add new key and new species
        if entry[1] not in taxa_dic.keys():  
                taxa_dic[entry[1]] = [entry[0]]


        ##else find matching key and add the species
        elif entry[1] in taxa_dic.keys():    
                taxa_dic[entry[1]].append(entry[0])


for i in taxa_dic.keys():
        print(i + ":\t" + str(taxa_dic[i]))
        


**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 

**********************************************************************
Rodentia:	['Mus domesticus', 'Gerbillus henleyi', 'Peromyscus crinitus', 'Cleithrionomys rutilus']
Carnivora:	['Canis lupus', 'Lyacon pictus', 'Arctocephalus gazella']
Afrosoricida:	['Microgale dobsoni', 'Microgale talazaci']
Chiroptera:	['Myotis lucifugus']

**********************************************************************

Code ran without errors

Time consumed = 0.02780s

======================================================================
Inspecting script file scope.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" A script looking at how global and local funtions are handled inside and outside functions."""

__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'

#PART 1
_a_global = 10  # a global variable

if _a_global >= 5:
    _b_global = _a_global + 5 # alsoa global variable

def a_function():
    """ shows how locals variables work"""
    _a_global = 5  # a local variable
    
    if _a_global >= 5:
        _b_global = _a_global + 5 # also a local variable
    
    _a_local = 4
    
    print("Inside the function, the value is ", _a_global)
    print("Inside the function, the value is ", _b_global)
    print("Inside the function, the value is ", _a_local)

    return None

a_function()

print("Outside the function, the value is ", _a_global)
print("Outside the function, the value is ", _b_global)

# PART 2
_a_global = 10

print("Outside the function, the value is ", _a_global)

def a_function():
    """ shows local vs global variables"""
    global _a_global
    _a_global = 5 
    _a_local = 4
    print("Inside the function, the value is ", _a_global)
    print("Inside the function, the value is ", _a_local)
    return None

a_function()
print("Outside the function, the value is ", _a_global)

# PART 3
def a_function():
    """ shows how assigning global variables works"""
    _a_global = 10

    def _a_function2():
        """ demonstrates how the global variable is handled in a fucntion"""
        global _a_global
        _a_global = 5
        _a_local = 4 

        print("Inside the function, the value of _a_global ", _a_global)
        print("Inside the function, the value of _a_local", _a_local)

        return None

a_function()

print("Outside the function, the value of _a_global now is ", _a_global)

#PART 4

def a_function():
    """ more global testing"""
    _a_global = 10

    def _a_function2():
        global _a_global
        _a_global = 20

    print("Before calling a_function, value of _a_global is ", _a_global)

    return None

    _a_function2()

    print("After calling _a_function2, value of _a_global is ", _a_global)

a_function()

print("The value of a_global in main workspace / namespace is ", _a_global)

#PART 5

_a_global = 10
def a_function():
    """ more global vs local """
    def _a_function2():
        """ even more global vs local"""
        global _a_global
        _a_global = 20

    print("Before calling a_function, value of _a_global is ", _a_global)

    _a_function2()
    
    print("After calling _a_function2, value of _a_global is ", _a_global)

a_function()

print("The value of a_global in main workspace / namespace is ", _a_global)
**********************************************************************

Testing scope.py...

scope.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 99.0

Output (only first 500 characters): 

**********************************************************************
Inside the function, the value is  5
Inside the function, the value is  10
Inside the function, the value is  4
Outside the function, the value is  10
Outside the function, the value is  15
Outside the function, the value is  10
Inside the function, the value is  5
Inside the function, the value is  4
Outside the function, the value is  5
Outside the function, the value of _a_global now is  5
Before calling a_function, value of _a_global is  10
The value of a_global in main workspace / namespace 
**********************************************************************

Code ran without errors

Time consumed = 0.02794s

======================================================================
Inspecting script file basic_io3.py...

File contents are:
**********************************************************************
""" Creates a binary file '../testp.p' containing a dictionary with 2 keys. """


#######################
# STORING OBJECTS
#######################
# To save an object (even complex) for alter use 
my_dictionary = {"a key": 10, "another key": 11}

import pickle
f = open('../sandbox/testp.p','wb') # note the b: accept binary
pickle.dump(my_dictionary, f)

## Laod the data again
f = open('../sandbox/testp.p', 'rb')
another_dictionary = pickle.load(f)
f.close

print(another_dictionary)**********************************************************************

Testing basic_io3.py...

basic_io3.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.0

Output (only first 500 characters): 

**********************************************************************
{'another key': 11, 'a key': 10}

**********************************************************************

Code ran without errors

Time consumed = 0.03769s

======================================================================
Inspecting script file cfexercises1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""A test of writting simple function to execute simple operation on a number, or list of numbers."""

__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'

## imports##
import sys

## constants##

##functions##

# What does each of foo_x do?
def foo_1(x):
    """ Takes a number x and finds the square root of it."""
    return x ** 0.5  # x to power .5?

def foo_2(x, y):
    """ Takes two numbers x and y and return the greater of the two. """
    if x > y:
        return x # return x if greater than y
    return y
def foo_3(x, y, z):
    """ Takes three numbers x, y, z.  
    First if x is greater than y, they are swapped.  
    Next if y is greater than z, they are swapped.
    The end result will be if x is greater than the 
    other two values then x is moved to the end of the list."""
    if x > y:           # swap x and y if x is greater
        tmp = y 
        y=x
        x = tmp
    if y > z:       #swap z and y if y is greater
        tmp = z 
        z = y
        y = tmp
    return [x, y, z]   # end result is if x is greater than y and z it swaps all positions to the left.

def foo_4(x):           
    """ Takes a number x and outputs x!. """
    result = 1      #x! factorial
    for i in range(1, x+1):
        result = result * i
    return result

def foo_5(x):   # a recursive function that calculates the factoria
    """ Takes a number x and outputs x!. """
    if x == 1:
        return 1
    return x * foo_5(x -1)

def foo_6(x): # Calculate the factorial of x in a different way
    """ Takes a number x and outputs x!. """
    facto = 1
    while x >= 1:
        facto = facto * x
        x = x - 1
    return facto




def main (argv):
    print(foo_1(4))
    print(foo_2(2,4))
    print(foo_3(9,5,3))
    print(foo_4(5))
    print(foo_5(5))
    print(foo_6(5))
    
    


if (__name__ =="__main__"):
    status = main(sys.argv)
    sys.exit(status)

**********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 98.5

Output (only first 500 characters): 

**********************************************************************
2.0
4
[5, 3, 9]
120
120
120

**********************************************************************

Code ran without errors

Time consumed = 0.02779s

======================================================================
Inspecting script file tuple.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Author: Donal Burns (db319@ic.ac.uk)
# Date: Oct 2019
# Desc: A script taking a tuple containing tuples with the latin name, common name and body mass of various bird species.  
#!/usr/bin/env python3
"""A script taking a tuple containing tuples with the latin name, common name and body mass of various bird species. """

__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'


birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line or output block by species 
# Hints: use the "print" command! You can use list comprehensions!
n = 1
tags = ["Species:", "Common Name:", "Mass:"]

# Take the tuple with latin, common name and mass
for species in birds:
    print("---Species " + str(n) + "---")

# Take each entry in the tuple and print it.
    for entry in species:
        print(entry)

    print("\n")
    n = n + 1
**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 98.5

Output (only first 500 characters): 

**********************************************************************
---Species 1---
Passerculus sandwichensis
Savannah sparrow
18.7


---Species 2---
Delichon urbica
House martin
19


---Species 3---
Junco phaeonotus
Yellow-eyed junco
19.5


---Species 4---
Junco hyemalis
Dark-eyed junco
19.6


---Species 5---
Tachycineata bicolor
Tree swallow
20.2



**********************************************************************

Code ran without errors

Time consumed = 0.02933s

======================================================================
Inspecting script file lc1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""A script taking birds latin names, common names and body mass and outputting them alone"""

__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'
# Author: Donal Burns (db319@ic.ac.uk)
# Date: Oct 2019
# Desc: A script taking birds latin names, common names and body mass and outputting them alone.


birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively. 

#latin names
latin = [bird[0] for bird in birds]
print(latin)

#Common Names
common = [bird[1] for bird in birds]
print(common)

#Body mass
mass = [bird[2] for bird in birds]
print(mass)
  
# (2) Now do the same using conventional loops (you can choose to do this 
# before 1 !). 

#pulls latin names
latin = []

for bird in birds:
    latin.append(bird[0])
print(latin)

#pulls common names
common = []

for bird in birds:
    common.append(bird[1])
print(common)

#pulls body mass
mass = []

for bird in birds:
    mass.append(bird[2])
print(mass)**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 98.5

Output (only first 500 characters): 

**********************************************************************
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]

**********************************************************************

Code ran without errors

Time consumed = 0.03363s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""A program which parses a list and takes all members of the 'Quercuss' genus and saves them to a sperate file in `../data`
"""




__appname__ = 'align_seqs_fasta.py'
__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'



import csv
import sys
import re ##regular expression module for quercus typos
#Define function
def is_an_oak(name):
    """ Returns True if name is starts with 'quercus', has some ability to allow typos to be correctly interpreted e.g. Qaecuss.  Will not accept if the user makes 3 typos in a row or has one typo and too many letters.  Have judged this to be an acceptable level of redundancy while maintaining strictness of passing.

    doctest
    >>> is_an_oak('Fagus syvatica')
    False
    >>> is_an_oak('Quercus maximus')
    True
    >>> is_an_oak('Qaercuss maximus')
    True
    >>> is_an_oak('Qaurcuss maximus')
    False
     """

    oak = name.lower()
    

    if oak.startswith('quercus'):
        return True
        ##checks for user typos begin
    if re.match(re.compile('q.e.c.s'), oak):
        return True 
    if re.match(re.compile('.u.r.c.s'), oak):
        return True

    return False

def main(argv): 
    """ Prints every row in the list in the order [Genus species].  Also specifies Genus.  If the row is an oak an additional row "FOUND AN OAK!" will be printed.  All oaks are then saved to ../data/JustOaksData.csv """
    f = open('../data/TestOaksData.csv','r')
    g = open('../data/JustOaksData.csv','w')
    taxa = csv.reader(f)
    csvwrite = csv.writer(g)
    oaks = set() ###############< should take the input and makes sure there is no doubles
    csvwrite.writerow(['Genus','species']) # print header for JustOaksData.csv
    for row in taxa:
        if row[0] == 'Genus': ## don't print 'Genus, species' in terminal
            None
        else:
            print(row)
            print ("The genus is: ") 
            print(row[0] + '\n')
            if is_an_oak(row[0]):
                print('FOUND AN OAK!\n')
                csvwrite.writerow([row[0], row[1]])    

    return 0
    
if (__name__ == "__main__"):
    status = main(sys.argv)**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 98.5

Output (only first 500 characters): 

**********************************************************************
['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!


**********************************************************************

Code ran without errors

Time consumed = 0.03447s

======================================================================
Inspecting script file oaks.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""Finds just those taxa that are oak trees from a list of species."""

__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'
# Author: Donal Burns (db319@ic.ac.uk)
# Date: Oct 2019
# Desc: Finds just those taxa that are oak trees from a list of species

taxa = ['Quercus robur', 
'Fraxinus exelsior', 
'Pinus sylvestris', 
'Quercus cerris', 
'Quercus patraea']

def is_an_oak(name):
    return name.lower().startswith('quercus ')

## Using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species)
print(oaks_loops)

## Using list comprehensions
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

## Get names in UPPER CASE using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper())
print(oaks_loops)

## Get names in UPPER CASE using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak])
print(oaks_lc)

**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 98.0

Output (only first 500 characters): 

**********************************************************************
{'Quercus patraea', 'Quercus robur', 'Quercus cerris'}
{'Quercus patraea', 'Quercus robur', 'Quercus cerris'}
{'QUERCUS CERRIS', 'QUERCUS ROBUR', 'QUERCUS PATRAEA'}
{'QUERCUS CERRIS', 'QUERCUS PATRAEA', 'QUERCUS ROBUR', 'FRAXINUS EXELSIOR', 'PINUS SYLVESTRIS'}

**********************************************************************

Code ran without errors

Time consumed = 0.03272s

======================================================================
Inspecting script file loops.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" A script practicing use of FOR loops in Python"""

__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'
# Author: Donal Burns (db319@ic.ac.uk)
# Date: Oct 2019
# Desc: A script practicing use of FOR loops in Python
for i in range(5):  #prints number from 1-5
    print(i)

my_list = [0, 2, "geronimo!", 3.0, True, False]  
# prints all elements in my_list
for k in my_list:
    print(k)

total = 0                          
 # takes each element in summands adds it to the sum of all previous elements and prints it each time.
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s 
    print(total)

# WHILE loops in Python
z = 0           # counts from 1-100, while printing each time
while z < 100:
    z = z + 1
    print(z)

# creates an infinite loop printing "GERONIMO! infinite loop! ctrl+c to stop" the whole time.
b = True  
while b:
    print("GERONIMO! infinite loop! ctrl+c to stop")
# ctrl + c to stop**********************************************************************

Testing loops.py...

loops.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 98.0

Output (only first 500 characters): 

**********************************************************************
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
GERONIMO! infinite loop! ctrl+c to stop
GERONIMO! infinite loop! ctrl+c to stop
GERONIMO! infinite loop! ctrl+c to stop
GERONIMO! infinite loop! ctrl+c to
**********************************************************************

Code ran without errors

Time consumed = 10.33765s

======================================================================
Inspecting script file using_name.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""A script looking at how __main__ is handled in python."""

__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'
# Author: Donal Burns (db319@ic.ac.uk)
# Date: Oct 2019
# Desc: A script looking at how __main__ is handled in python.
#Filename: using_name.py

if __name__ == '__main__':
    print('This program is being run by itself')

else:
    print("I am being imported from another module")
    **********************************************************************

Testing using_name.py...

using_name.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 98.0

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself

**********************************************************************

Code ran without errors

Time consumed = 0.06387s

======================================================================
Inspecting script file align_seqs.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" A programme which takes two genetic sequences and aligns them to provide the best direct match possible.
It will run even if no inputs are given using short examples sequences, by using align_seqs.csv found within `../data` """


__appname__ = 'align_seqs.py'
__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'

## possible improvements
# use tags in file



##Imports##

import sys 
import csv 



###for differentiating files

##if not user arguments are given run with test files
if len(sys.argv) == 1:

    with open("../data/align_seqs.csv") as file:
        csv_reader = csv.reader(file, delimiter = ",")
        for s in csv_reader:
            seq1, seq2 = s[0], s[1]
#run with user designated file otherwise
else:

    with open(sys.argv[1]) as file:
        csv_reader = csv.reader(file, delimiter = ",")
        for s in csv_reader:
            seq1, seq2 = s[0], s[1]




# Two example sequences to match, will run should no other files be specified.  found as align_seqs.csv in ../Results
# seq2 = "ATCGCCGGATTACGGG"
# seq1 = "CAATTCGGAT"

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    """ A function that computes a score by returning the number of matches starting from arbitrary startpoint (chosen by user)"""
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 

def main(argv):
    """prints all alignments with scores and saves the alignment with the best score to ../Results"""
    with open("../Results/seq_alignment.txt","w") as file:
        # fileWrite = csv.writer(file)
        print(my_best_align)
        print(s1)
        print("Best score:", my_best_score)
        ##writes the file with best score        
        file.write(my_best_align + "\n")
        file.write(s1 + "\n")
        file.write("Best score:" + str(my_best_score) + "\n")




if (__name__ =="__main__"):
    status = main(sys.argv)
    sys.exit(status)**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 98.0

Output (only first 500 characters): 

**********************************************************************
--*----------
 "CAATTCGGAT"
ATCGCCGGATTACGGG
1
 
.----------*--
. "CAATTCGGAT"
ATCGCCGGATTACGGG
1
 
..--*----------
.. "CAATTCGGAT"
ATCGCCGGATTACGGG
1
 
...--*---*------
... "CAATTCGGAT"
ATCGCCGGATTACGGG
2
 
....----***--*--
.... "CAATTCGGAT"
ATCGCCGGATTACGGG
4
 
.....---*-*-***-
..... "CAATTCGGAT"
ATCGCCGGATTACGGG
5
 
......--------**
...... "CAATTCGGAT"
ATCGCCGGATTACGGG
2
 
.......----*---*
....... "CAATTCGGAT"
ATCGCCGGATTACGGG
2
 
........---*----
........ "CAATTCGGAT"
ATCGCCGGATTACGGG
1
 
...
**********************************************************************

Code ran without errors

Time consumed = 0.05104s

======================================================================
Inspecting script file basic_io2.py...

File contents are:
**********************************************************************
""" Takes# '../sandbox/testout.txt' and adds new lines at the end of each line. """

###########################
# FILE INPUT
###########################
# save the elements of a list to a file
list_to_save = range(100)

f = open('../sandbox/testout.txt','w')
for i in list_to_save:
    f.write(str(i) + '/n') ## Add a new line at the end

f.close()**********************************************************************

Testing basic_io2.py...

basic_io2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 98.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.02581s

======================================================================
Inspecting script file sysargv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" A script examining how sys.argv is handeled in Python."""

__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'
# Author: Donal Burns (db319@ic.ac.uk)
# Date: Oct 2019
# Desc: A script examining how sys.argv is handeled in Python.

import sys
print("This is the name of the script: ", sys.argv[0])
print("Number of arguments: ", len(sys.argv))
print("The arguments are: ", str(sys.argv))

**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 98.0

Output (only first 500 characters): 

**********************************************************************
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.02636s

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" A programme which takes two genetic sequences and aligns them to provide the best direct match possible.

It will run even if no inputs are given using short examples sequences, by using files 407228326.fasta and 407228412.fasta found within ../data/fasta """


__appname__ = 'align_seqs_fasta.py'
__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'

## possible improvements
# use tags in file

## little print to terminal to show user the script is running.
print("Processing...")
##Imports##

import sys 
import csv 



###for differentiating files


##if not user arguments are given run with test files
if len(sys.argv) == 1:

    with open("../data/fasta/407228326.fasta","r") as reader:
        
        seq1 = ""
        for s in reader.readlines()[1:]:  #reads all lines starting with line 2
            s = s.rstrip('\n')
            seq1 = seq1 + s

    with open("../data/fasta/407228412.fasta") as reader:
        
        seq2 = ""
        for s in reader.readlines()[1:]:
            s = s.rstrip('\n')
            seq2 = seq2 + s
    
#run with user designated file otherwise
else:

    with open(sys.argv[1]) as reader:

        seq1 = ""
        for s in reader.readlines()[1:]:
            s = s.rstrip('\n')
            seq1 = seq1 + s

    with open(sys.argv[2]) as reader:
        
        seq2 = ""
        for s in reader.readlines()[1:]:
            s = s.rstrip('\n')
            seq1 = seq2 + s

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    """ A function that computes a score by returning the number of matches starting from arbitrary startpoint (chosen by user)"""
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    # print("." * startpoint + matched)           
    # print("." * startpoint + s2)
    # print(s1)
    # print(score) 
    # print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

test = []   ##test for more than one highest score

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z >= my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z
        test.append(z) 


def main(argv):
    """prints all alignments with scores and saves the alignment with the best score to ../Results"""
    with open("../Results/seq_alignment_fasta.txt","w") as file:
        # fileWrite = csv.writer(file)
        
        ##writes the file with best score        
        file.write(my_best_align + "\n")
        file.write(s1 + "\n")
        file.write("Best score:" + str(my_best_score) + "\n")
        print("DING! All Done.")


if (__name__ =="__main__"):
    status = main(sys.argv)
    sys.exit(status)**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 98.0

Output (only first 500 characters): 

**********************************************************************
Processing...
DING! All Done.

**********************************************************************

Code ran without errors

Time consumed = 3.41362s

======================================================================
Inspecting script file control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""Some functions exemplicfying the use of control statements."""
#docstrings are considered part of the running code (normal comments are
# stripped).  Hence, you can access you dcostrings at run time.

__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'


## imports ##
import sys # module to interface our program with the operating system.

## constants ##


## functions ##

def even_or_odd(x=0): # if not specified, x should take value 0.

    """Find whether a number x is even or odd"""
    if x % 2 == 0: # The conditional if
        return "%d is Even!" % x 
    return "%d is Odd!" % x
    

def largest_divisor_five(x=120):
    """Find whic is the largest divisor of x among 2,3,4,5."""

    largest = 0

    if x % 5 == 0:
        largest = 5
    
    elif x % 4 == 0: #means" else if"
        largest = 4

    elif x % 3 == 0:
        largest = 3

    elif x % 2 == 0:
        largest = 2

    else:
        return "No divisor found %d!" % x 
        # Each function can return a value or a variable.

    return " The largest divisor of %d is %d" % (x, largest)


def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): # "range" returns a sequence of integers
        if x % i == 0:
            print("%d is not a prime: %d is a divisor" % (x, i))
            return False
        print("%d is a prime!" % x)
        return True

def find_all_primes(x=22):
    """ Find all primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
        if is_prime(i):
            allprimes.append(i)
    print("There are %d primes between 2 and %d" % (len(allprimes), x))
    return allprimes

def main(argv):
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0 

    
if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 97.5

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
 The largest divisor of 120 is 5
No divisor found 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is a prime!
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is a prime!
16 is not a prime: 2 is a divisor
17 is a prime!
18 is not a 
**********************************************************************

Code ran without errors

Time consumed = 0.02873s

======================================================================
Inspecting script file debugm.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
#!/usr/bin/env python3
"""Simple piece of code used to practice debugging in python"""
__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'
## Desc: script for debugging.

def makeabug(x):
    y = x**4
    z = 0.
    y = y/z
    return y

makeabug(25)
**********************************************************************

Testing debugm.py...

debugm.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 97.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "debugm.py", line 14, in <module>
    makeabug(25)
  File "debugm.py", line 11, in makeabug
    y = y/z
ZeroDivisionError: float division by zero

======================================================================
Inspecting script file test_control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""A script to test how to write and use doctests using some functions exemplicfying the use of control statements."""

__author__ = 'Donal Burns (db319@ic.ac.uk)'
__version__ = '0.0.1'


## imports ##
import sys 
import doctest # import doctest modules
## constants ##


## functions ##

def even_or_odd(x=0): 
    """Find whether a number x is even or odd

    >>> even_or_odd(10)
    '10 is Even!'

    >>> even_or_odd(5)
    '5 is Odd!'

    whenever a float is provided, the the closest interger is used:
    >>> even_or_odd(3.2)
    '3 is Odd!'

    in case of negative numbers, the positive is taken:
    >>> even_or_odd(-2)
    '-2 is Even!'
        
    """
    # Define function to be tested.
    if x % 2 == 0: # The conditional if
        return "%d is Even!" % x 
    return "%d is Odd!" % x
    

########## VVV supressed for testing VVV ##############

def largest_divisor_five(x=120):
    """Find whic is the largest divisor of x among 2,3,4,5."""

    largest = 0

    if x % 5 == 0:
        largest = 5
    
    elif x % 4 == 0: #means" else if"
        largest = 4

    elif x % 3 == 0:
        largest = 3

    elif x % 2 == 0:
        largest = 2

    else:
        return "No divisor found %d!" % x # Each function can return a value or a variable.

    return " The largest divisor of %d is %d" % (x, largest)


def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): # "range" returns a sequence of integers
        if x % i == 0:
            print("%d is not a prime: %d is a divisor" % (x, i))
            return False
        print("%d is a prime!" % x)
        return True

def find_all_primes(x=22):
    """ Find all primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
        if is_prime(i):
            allprimes.append(i)
    print("There are %d primes between 2 and %d" % (len(allprimes), x))
    return allprimes

def main(argv):
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0 

    
if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)

doctest.testmod() # To run with embedded tests.**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 96.5

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
 The largest divisor of 120 is 5
No divisor found 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is a prime!
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is a prime!
16 is not a prime: 2 is a divisor
17 is a prime!
18 is not a 
**********************************************************************

Code ran without errors

Time consumed = 0.05996s

======================================================================
Inspecting script file basic_io1.py...

File contents are:
**********************************************************************
""" Takes a file prints it then removes blank lines and outputs to the terminal."""




###########################
# FILE INPUT
###########################
# Open a file for reading
f = open('../sandbox/test.txt', 'r')
#use "implicit" for loop:
#if the object is a file, python will cycle over lines
for line in f:
    print(line)

#  close the file 
f.close()

# Same example, skip the blank lines
f = open('../sandbox/test.txt', 'r')
for line in f:
    if len(line.strip()) > 0:
        print(line)

f.close()   **********************************************************************

Testing basic_io1.py...

basic_io1.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 96.5

Output (only first 500 characters): 

**********************************************************************
First Line

Second Line



Third Line



Fourth Line
First Line

Second Line

Third Line

Fourth Line

**********************************************************************

Code ran without errors

Time consumed = 0.03013s

======================================================================
======================================================================
Finished running scripts

Ran into 2 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 96.5

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!